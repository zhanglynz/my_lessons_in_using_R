[
["index.html", "The lessons I learned in using R Preface", " The lessons I learned in using R Lingyun Zhang 2018-3-23 Preface To be written. “Failures teach success.” "],
["small-lessons.html", "1 Small lessons 1.1 Always use stringsAsFactors = FALSE 1.2 Always use na.rm = TRUE 1.3 Always use seq_along 1.4 Always use drop = FALSE 1.5 Always use dir.create() 1.6 Leap year problem 1.7 NA may cause troubles 1.8 using tidyr::spread() 1.9 Prefix and suffix", " 1 Small lessons 1.1 Always use stringsAsFactors = FALSE When use data.frame to create a dataframe, always use stringsAsFactors = FALSE, otherwise some facotr variable may cause unexpected troubles. 1.2 Always use na.rm = TRUE The following code is correct in terms of syntax, but it does not give the result that we expect. x &lt;- c(1:3, NA, 4) (y &lt;- sum(x)) ## [1] NA Instead, we should use x &lt;- c(1:3, NA, 4) (y &lt;- sum(x, na.rm = TRUE)) ## [1] 10 1.3 Always use seq_along Sometime ago, I often write in my program something like s &lt;- 0 for(i in 1:length(x)) s &lt;- s + 1 This piece of code may fail because the length of x may be 0. The safer and right way is to use seq_along. So, the code should be changed to s &lt;- 0 for(i in seq_along(x)) s &lt;- s + 1 1.4 Always use drop = FALSE Let’s look at the following example: x &lt;- diag(3) y1 &lt;- x[-1, ] y2 &lt;- x[-c(1, 2), ] y3 &lt;- x[-c(1, 2, 3), ] (is.matrix(y1)) ## [1] TRUE (is.matrix(y2)) ## [1] FALSE (is.matrix(y3)) ## [1] TRUE This is interesting, isn’t? The above example shows a tiny bit of inconsistency in R; this inconsistency is dangerous for programmers. To remove the inconsistency, we should change the code to x &lt;- diag(3) y1 &lt;- x[-1, , drop = FALSE] y2 &lt;- x[-c(1, 2), , drop = FALSE] y3 &lt;- x[-c(1, 2, 3), , drop = FALSE] (is.matrix(y1)) ## [1] TRUE (is.matrix(y2)) ## [1] TRUE (is.matrix(y3)) ## [1] TRUE (y3) ## [,1] [,2] [,3] Note that y3 is a matrix of 0 rows and 3 columns. y3 is not a real matrix in the mathematical sense but it is a legal one in R. 1.5 Always use dir.create() I have the habit of creating folders by hand, but for writing programs that will be used by other people we should always do the following: if(!dir.exists(&quot;./Folder-name&quot;)) dir.create(&quot;./Folder-name&quot;) 1.6 Leap year problem Suppose we want to get data from today back to three years ago from a database; we may write code like the following: library(lubridate) (query_start &lt;- today() - years(3)) ## [1] &quot;2018-03-21&quot; The code are OK most of time, but we will be in trouble if today is February 29, 2016. Let’s see following code: (query_start &lt;- as.Date(&quot;2016-02-29&quot;) - years(3)) ## [1] NA We got an NA; of course this is not what we wanted! We can write safer code as follows: library(lubridate) m_d &lt;- substring(ymd(today()), 6, 10) if(m_d == &quot;02-29&quot;) { query_start &lt;- today() + days(1) - years(3) - days(1) } else { query_start &lt;- today() - years(3) } (query_start) ## [1] &quot;2018-03-21&quot; 1.7 NA may cause troubles We must be very cautious when we are dealing with NA’s. The following code looked OK, but it does not give what we expect. library(dplyr) a_df &lt;- data.frame(x = c(letters[1:5], rep(NA, 3))) b_df &lt;- a_df %&gt;% filter(x != &quot;c&quot;) The right code should be library(dplyr) a_df &lt;- data.frame(x = c(letters[1:5], rep(NA, 3))) b_df &lt;- a_df %&gt;% filter(x != &quot;c&quot; | is.na(x)) because we want to keep the rows where x is NA. 1.8 using tidyr::spread() I saw an example from https://www.r-bloggers.com/workaround-for-tidyrspread-with-duplicate-row-identifiers/, and I created a new example by tweaking the original one. library(tidyr) ## Warning: package &#39;tidyr&#39; was built under R version 3.4.4 library(dplyr) long_table &lt;- data.frame(age = sample(15:29, 5), gender = sample(c(&quot;m&quot;, &quot;f&quot;), 5, replace = TRUE)) (long_table) ## age gender ## 1 24 m ## 2 27 m ## 3 28 m ## 4 21 f ## 5 16 f ## this does not work # wide_table &lt;- # long_table %&gt;% # spread(key = gender, value = age) ## this works wide_table &lt;- long_table %&gt;% mutate(n = row_number()) %&gt;% spread(key = gender, value = age) %&gt;% select(-n) %&gt;% arrange(f) (wide_table) ## f m ## 1 16 NA ## 2 21 NA ## 3 NA 24 ## 4 NA 27 ## 5 NA 28 1.9 Prefix and suffix library(dplyr) library(stringr) fake_data &lt;- data.frame(x = paste0(sample(letters[1:3], 10, replace = TRUE), &quot;_&quot;, sample(1:10, 10, replace = TRUE), &quot;_&quot;, sample(c(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;), 10, replace = TRUE)), y = rnorm(10)) new_df &lt;- fake_data %&gt;% mutate(the_prefix = str_extract(x, &quot;^[a-zA-Z]+[_]&quot;)) %&gt;% mutate(the_prefix = gsub(&quot;_&quot;, &quot;&quot;, the_prefix, fixed = TRUE)) %&gt;% mutate(rev_x = stringi::stri_reverse(x)) %&gt;% mutate(the_suffix = str_extract(rev_x, &quot;^[a-zA-Z]+[_]&quot;)) %&gt;% mutate(the_suffix = gsub(&quot;_&quot;, &quot;&quot;, the_suffix, fixed = TRUE)) %&gt;% mutate(the_suffix = stringi::stri_reverse(the_suffix)) %&gt;% select(-rev_x) new_df ## x y the_prefix the_suffix ## 1 a_9_cc 0.76431177 a cc ## 2 a_7_aa -0.04601007 a aa ## 3 b_6_bb 0.51371564 b bb ## 4 a_7_bb -0.27063023 a bb ## 5 a_8_aa -0.33177523 a aa ## 6 b_4_aa -0.01735982 b aa ## 7 a_4_bb -0.76250077 a bb ## 8 c_3_cc 0.40885810 c cc ## 9 b_9_cc -0.95300011 b cc ## 10 b_2_cc -1.95906362 b cc "],
["big-lessons.html", "2 Big lessons 2.1 Counting is not that easy 2.2 Joining tables, be careful! 2.3 Using group_by and arrange", " 2 Big lessons 2.1 Counting is not that easy Finding number of rows under some constraints and then getting some a ratio is a common practice for an analyst who is doing official statistics. But sometimes counting is not that easy when a record is not the same as a response. An example is that people are allowed to make multiple choices. We use the following fake data to tell two stories. library(readr) the_url &lt;- &quot;https://raw.githubusercontent.com/LarryZhang2016/Data/master/fake_data_4_counting_example.csv&quot; fake_data &lt;- read_csv(the_url) print.data.frame(fake_data) ## ID Q_NO answers ## 1 1 1 C ## 2 1 2 B ## 3 1 2 A ## 4 1 3 C ## 5 1 4 A ## 6 1 4 C ## 7 2 1 A ## 8 2 1 B ## 9 2 2 C ## 10 2 2 A ## 11 2 2 B ## 12 2 3 C ## 13 2 4 A ## 14 2 4 B ## 15 2 4 C ## 16 3 1 C ## 17 3 1 A ## 18 3 2 A ## 19 3 3 A ## 20 3 3 B ## 21 3 4 A ## 22 4 1 A ## 23 4 1 B ## 24 4 1 C ## 25 4 2 C ## 26 4 2 B ## 27 4 2 A ## 28 4 3 A ## 29 4 3 B ## 30 4 4 B ## 31 4 4 C ## 32 4 4 A ## 33 5 1 A ## 34 5 2 A ## 35 5 3 A ## 36 5 3 B ## 37 5 4 B ## 38 5 4 C ## 39 5 4 A Story 1: Find the number of respondents. The code below is wrong! library(dplyr) no_of_respondents &lt;- fake_data %&gt;% summarise(n = n()) print.data.frame(no_of_respondents) ## n ## 1 39 Here we should use n_distinct(), and the correct code is: library(dplyr) no_of_respondents &lt;- fake_data %&gt;% summarise(n = n_distinct(ID)) print.data.frame(no_of_respondents) ## n ## 1 5 Story 2: Tally the data with one dimension be Question-Number and the other dimension be Answers, and then create another table, which shows the proportions of people made the choice. no_of_people_choose_A_4_Q1 &lt;- fake_data %&gt;% group_by(Q_NO, answers) %&gt;% tally() %&gt;% tidyr::spread(key = answers, value = n) print.data.frame(no_of_people_choose_A_4_Q1) ## Q_NO A B C ## 1 1 4 2 3 ## 2 2 5 3 2 ## 3 3 3 3 2 ## 4 4 5 3 4 proportion_table &lt;- mutate(no_of_people_choose_A_4_Q1, A = A / no_of_respondents$n, B = B / no_of_respondents$n, C = C / no_of_respondents$n) print.data.frame(proportion_table) ## Q_NO A B C ## 1 1 0.8 0.4 0.6 ## 2 2 1.0 0.6 0.4 ## 3 3 0.6 0.6 0.4 ## 4 4 1.0 0.6 0.8 Note that the denominator should be 5 instead of 39. 2.2 Joining tables, be careful! When the values for one key variable are not unique, we must pay more attention to what we get from joining two tables – sometimes it’s not really what we want. Example 1: library(dplyr) (a_table &lt;- data_frame(x = letters[1:5], y = 1:5)) ## # A tibble: 5 x 2 ## x y ## &lt;chr&gt; &lt;int&gt; ## 1 a 1 ## 2 b 2 ## 3 c 3 ## 4 d 4 ## 5 e 5 (b_table &lt;- data_frame(x = c(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;a&quot;, &quot;c&quot;))) ## # A tibble: 5 x 1 ## x ## &lt;chr&gt; ## 1 a ## 2 b ## 3 b ## 4 a ## 5 c Here we want to use x as the key and find “overlap” between a_table and b_table. We may write down (c_table &lt;- inner_join(a_table, b_table, by = &quot;x&quot;)) ## # A tibble: 5 x 2 ## x y ## &lt;chr&gt; &lt;int&gt; ## 1 a 1 ## 2 a 1 ## 3 b 2 ## 4 b 2 ## 5 c 3 but this code does not give the result that we want. so the correct code should be temp_b_table &lt;- b_table %&gt;% distinct(x) c_table &lt;- a_table %&gt;% inner_join(temp_b_table, by = &quot;x&quot;) (c_table) ## # A tibble: 3 x 2 ## x y ## &lt;chr&gt; &lt;int&gt; ## 1 a 1 ## 2 b 2 ## 3 c 3 Or, we can use semi_join(). c_table &lt;- a_table %&gt;% semi_join(b_table, by = &quot;x&quot;) (c_table) ## # A tibble: 3 x 2 ## x y ## &lt;chr&gt; &lt;int&gt; ## 1 a 1 ## 2 b 2 ## 3 c 3 Example 2: a_table &lt;- data_frame(x = letters[1:5], y = 1:5) d_table &lt;- data_frame(x = c(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;a&quot;, &quot;c&quot;), z = 6:10) e_table &lt;- a_table %&gt;% left_join(d_table, by = &quot;x&quot;) (e_table) ## # A tibble: 7 x 3 ## x y z ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 a 1 6 ## 2 a 1 9 ## 3 b 2 7 ## 4 b 2 8 ## 5 c 3 10 ## 6 d 4 NA ## 7 e 5 NA Note that values of x in e_table are not unique and e_table has more rows than a_table. 2.3 Using group_by and arrange “grouped arrange() is the same as ungrouped; unless you set .by_group = TRUE, in which case it orders first by the grouping variables” (Introduction to dplyr) The following example shows the difference between using .by_group = TRUE and withou using it. library(dplyr) my_func &lt;- function(x) {n &lt;- sum(is.na(x)) if(n == 0) return(x) L &lt;- length(x) x[(L+1-n):L] &lt;- x[L-n] + (1:n) return(x) } temp_v &lt;- c(&#39;a&#39;, &#39;b&#39;, letters[1:3], &#39;b&#39;, &#39;c&#39;, letters[1:3]) L &lt;- length(temp_v) df &lt;- data.frame(x = temp_v, y = c((L-3):1, NA, NA, NA)) (df) ## x y ## 1 a 7 ## 2 b 6 ## 3 a 5 ## 4 b 4 ## 5 c 3 ## 6 b 2 ## 7 c 1 ## 8 a NA ## 9 b NA ## 10 c NA # frist attempt, without using .by_group = TRUE # surprisingly (goo!) we can get what we want df_new_1 &lt;- df %&gt;% group_by(x) %&gt;% arrange(y,) %&gt;% mutate(z = my_func(y)) (df_new_1) ## # A tibble: 10 x 3 ## # Groups: x [3] ## x y z ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; ## 1 c 1 1 ## 2 b 2 2 ## 3 c 3 3 ## 4 b 4 4 ## 5 a 5 5 ## 6 b 6 6 ## 7 a 7 7 ## 8 a NA 8 ## 9 b NA 7 ## 10 c NA 4 # second try, using .by_group = TRUE # this is the code supposed to be df_new_2 &lt;- df %&gt;% group_by(x) %&gt;% arrange(y, .by_group = TRUE) %&gt;% mutate(z = my_func(y)) (df_new_2) ## # A tibble: 10 x 3 ## # Groups: x [3] ## x y z ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; ## 1 a 5 5 ## 2 a 7 7 ## 3 a NA 8 ## 4 b 2 2 ## 5 b 4 4 ## 6 b 6 6 ## 7 b NA 7 ## 8 c 1 1 ## 9 c 3 3 ## 10 c NA 4 identical(arrange(df_new_1, x), df_new_2) ## [1] TRUE "],
["some-useful-tricks.html", "3 Some useful tricks 3.1 Removing rows under constraints 3.2 dplyr programming 3.3 Using apply and map family of functions 3.4 Regular expressions basic", " 3 Some useful tricks 3.1 Removing rows under constraints We discuss two cases. Case 1: removing rows that contain NA. For this case, we can use na.omit() or complete.cases(). Let us see the following example. Example: a_df &lt;- data_frame(x = c(&quot;a&quot;, NA, &quot;b&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;), y = c(runif(5), NA), z = c(LETTERS[1:3], NA, LETTERS[5:6])) (a_df) ## # A tibble: 6 x 3 ## x y z ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 a 0.791 A ## 2 &lt;NA&gt; 0.633 B ## 3 b 0.567 C ## 4 d 0.386 &lt;NA&gt; ## 5 e 0.252 E ## 6 f NA F # using na.omit to remove rows that have NA b_df &lt;- a_df %&gt;% na.omit() (b_df) ## # A tibble: 3 x 3 ## x y z ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 a 0.791 A ## 2 b 0.567 C ## 3 e 0.252 E # or using complete.cases c_df &lt;- a_df[complete.cases(a_df) == TRUE, ] (c_df) ## # A tibble: 3 x 3 ## x y z ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 a 0.791 A ## 2 b 0.567 C ## 3 e 0.252 E Case 2: removing rows contain some a specific symbol, e.g. “ZZZ”. Here the trick is to use rlang::sym. Example: library(dplyr) a_df &lt;- data_frame(x = c(&quot;a&quot;, &quot;ZZZ&quot;, &quot;b&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;), y = c(letters[1:5], &quot;ZZZ&quot;), z = c(LETTERS[1:3], &quot;ZZZ&quot;, LETTERS[5:6]), w = rnorm(6)) (a_df) ## # A tibble: 6 x 4 ## x y z w ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 a a A -0.332 ## 2 ZZZ b B -0.656 ## 3 b c C 0.643 ## 4 d d ZZZ 1.72 ## 5 e e E -2.05 ## 6 f ZZZ F 0.993 cols &lt;- colnames(a_df) b_df &lt;- a_df for(col in cols) {b_df &lt;- filter(b_df, (!!rlang::sym(col)) != &quot;ZZZ&quot;) } (b_df) ## # A tibble: 3 x 4 ## x y z w ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 a a A -0.332 ## 2 b c C 0.643 ## 3 e e E -2.05 NB: In the above, we must use parentheses around !!rlang::sym(col). 3.2 dplyr programming The good references are: https://cran.r-project.org/web/packages/dplyr/vignettes/programming.html https://edwinth.github.io/blog/dplyr-recipes/ Here, we try several examples. Example 1: square a variable in a dataframe, using rlang::sym() and !! (bang, bang) library(dplyr) sq_a_var &lt;- function(df, var) {new_var_name &lt;- paste0(var, &quot;_sq&quot;) new_df &lt;- df %&gt;% mutate(!!rlang::sym(new_var_name) := (!!rlang::sym(var))^2) new_df } a_df &lt;- data.frame(x = 1:3, y = 2:4) (sq_a_var(a_df, &quot;x&quot;)) ## x y x_sq ## 1 1 2 1 ## 2 2 3 4 ## 3 3 4 9 (sq_a_var(a_df, &quot;y&quot;)) ## x y y_sq ## 1 1 2 4 ## 2 2 3 9 ## 3 3 4 16 Version 2, in which we use dplyr::enquo() and dplyr::quo_name() and !! (bang, bang). library(dplyr) sq_a_var &lt;- function(df, var) {var_enquo &lt;- enquo(var) new_var_name &lt;- paste0(quo_name(var_enquo), &quot;_sq&quot;) new_df &lt;- df %&gt;% mutate(!!new_var_name := (!!var_enquo)^2) new_df } a_df &lt;- data.frame(x = 1:3, y = 2:4) (sq_a_var(a_df, x)) ## x y x_sq ## 1 1 2 1 ## 2 2 3 4 ## 3 3 4 9 (sq_a_var(a_df, y)) ## x y y_sq ## 1 1 2 4 ## 2 2 3 9 ## 3 3 4 16 Notice that in the above we use bare x or bare y rather than “x” or “y”. Example 2: find frequency of a variable, using enquo() and !! (bang, bang) library(dplyr) set.seed(20180425) a_df &lt;- data.frame(x = sample(letters[1:3], 6, replace = TRUE), y = sample(LETTERS[1:3], 6, replace = TRUE)) freq_table &lt;- function(df, var) {n &lt;- nrow(df) var_enqo &lt;- enquo(var) re &lt;- df %&gt;% group_by(!!var_enqo) %&gt;% summarise(freq = n() / n) re } (freq_table(a_df, x)) ## # A tibble: 3 x 2 ## x freq ## &lt;fct&gt; &lt;dbl&gt; ## 1 a 0.167 ## 2 b 0.167 ## 3 c 0.667 (freq_table(a_df, y)) ## # A tibble: 3 x 2 ## y freq ## &lt;fct&gt; &lt;dbl&gt; ## 1 A 0.167 ## 2 B 0.333 ## 3 C 0.5 Example 3: group-by more than a variable, using quos() and !!! library(dplyr) set.seed(20180425) a_df &lt;- data.frame(x = sample(letters[1:3], 6, replace = TRUE), y = sample(LETTERS[1:3], 6, replace = TRUE), z = as.character(rep(1:3, each = 2))) summ_a_few_vars &lt;- function(df, ...) {groupby_var &lt;- quos(...) re &lt;- df %&gt;% group_by(!!!groupby_var) %&gt;% summarise(freq = n()) re } (a_df) ## x y z ## 1 b B 1 ## 2 c B 1 ## 3 c C 2 ## 4 c C 2 ## 5 a A 3 ## 6 c C 3 (summ_a_few_vars(a_df, x, y)) ## # A tibble: 4 x 3 ## # Groups: x [3] ## x y freq ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 a A 1 ## 2 b B 1 ## 3 c B 1 ## 4 c C 3 (summ_a_few_vars(a_df, y, z)) ## # A tibble: 4 x 3 ## # Groups: y [3] ## y z freq ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 A 3 1 ## 2 B 1 2 ## 3 C 2 2 ## 4 C 3 1 Version 2, in which we use rlang::syms() and !!! library(dplyr) set.seed(20180425) a_df &lt;- data.frame(x = sample(letters[1:3], 6, replace = TRUE), y = sample(LETTERS[1:3], 6, replace = TRUE), z = as.character(rep(1:3, each = 2))) summ_a_few_vars &lt;- function(df, ...) {groupby_var &lt;- rlang::syms(...) re &lt;- df %&gt;% group_by(!!!groupby_var) %&gt;% summarise(freq = n()) re } (a_df) ## x y z ## 1 b B 1 ## 2 c B 1 ## 3 c C 2 ## 4 c C 2 ## 5 a A 3 ## 6 c C 3 (summ_a_few_vars(a_df, list(&quot;x&quot;, &quot;y&quot;))) ## # A tibble: 4 x 3 ## # Groups: x [3] ## x y freq ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 a A 1 ## 2 b B 1 ## 3 c B 1 ## 4 c C 3 (summ_a_few_vars(a_df, list(&quot;y&quot;, &quot;z&quot;))) ## # A tibble: 4 x 3 ## # Groups: y [3] ## y z freq ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 A 3 1 ## 2 B 1 2 ## 3 C 2 2 ## 4 C 3 1 3.3 Using apply and map family of functions Example 1: (a) Create a fake data frame which has three columns: group_ID, list_1 and list_2, where both list_1 and list_2 are list of lists; (b) find the intersection of list_1 and list_2 and the number of elements in the intersection. The key is to use mapply() and sapply. library(dplyr) set.seed(12022018) # temp data_frame # this is to make the fake data more &quot;real&quot; temp_df &lt;- data_frame(group_ID = 4L, L_1 = list(&quot;a&quot;), L_2 = list(NULL)) # fake data_frame fk_df &lt;- data_frame(group_ID = sample(1:3, 30, replace = TRUE), v1 = sample(c(letters, NA), 30, replace = TRUE), v2 = sample(c(letters, NA), 30, replace = TRUE)) %&gt;% group_by(group_ID) %&gt;% summarise(L_1 = list(v1), L_2 = list(v2)) %&gt;% bind_rows(temp_df) result_df &lt;- fk_df %&gt;% mutate(inter_set = mapply(intersect, L_1, L_2)) %&gt;% mutate(n = sapply(inter_set, length)) result_df ## # A tibble: 4 x 5 ## group_ID L_1 L_2 inter_set n ## &lt;int&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt; &lt;int&gt; ## 1 1 &lt;chr [9]&gt; &lt;chr [9]&gt; &lt;chr [0]&gt; 0 ## 2 2 &lt;chr [14]&gt; &lt;chr [14]&gt; &lt;chr [5]&gt; 5 ## 3 3 &lt;chr [7]&gt; &lt;chr [7]&gt; &lt;chr [0]&gt; 0 ## 4 4 &lt;chr [1]&gt; &lt;NULL&gt; &lt;NULL&gt; 0 The map version: library(dplyr) library(purrr) set.seed(12022018) # temp data_frame # this is to make the fake data more &quot;real&quot; temp_df &lt;- data_frame(group_ID = 4L, L_1 = list(&quot;a&quot;), L_2 = list(NULL)) # fake data_frame fk_df &lt;- data_frame(group_ID = sample(1:3, 30, replace = TRUE), v1 = sample(c(letters, NA), 30, replace = TRUE), v2 = sample(c(letters, NA), 30, replace = TRUE)) %&gt;% group_by(group_ID) %&gt;% summarise(L_1 = list(v1), L_2 = list(v2)) %&gt;% bind_rows(temp_df) result_df &lt;- fk_df %&gt;% mutate(inter_set = map2(L_1, L_2, intersect)) %&gt;% # or using pmap # mutate(inter_set = pmap(list(L_1, L_2), intersect)) %&gt;% mutate(n = map_int(inter_set, length)) result_df ## # A tibble: 4 x 5 ## group_ID L_1 L_2 inter_set n ## &lt;int&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt; &lt;int&gt; ## 1 1 &lt;chr [9]&gt; &lt;chr [9]&gt; &lt;chr [0]&gt; 0 ## 2 2 &lt;chr [14]&gt; &lt;chr [14]&gt; &lt;chr [5]&gt; 5 ## 3 3 &lt;chr [7]&gt; &lt;chr [7]&gt; &lt;chr [0]&gt; 0 ## 4 4 &lt;chr [1]&gt; &lt;NULL&gt; &lt;NULL&gt; 0 Example 2: (a) Create a fake data frame, which has columns of sex, age and score; (b) for each column, find its mode (the most frequent one) and the frequency. The key is to use sapply(). library(dplyr) set.seed(12022018) fk_df &lt;- # using data_frame rather than data.frame, for dealing with &quot;negative&quot; factor effect data_frame(sex = sample(c(&quot;M&quot;, &quot;F&quot;), 100, replace = TRUE), age = sample(19:25, 100, replace = TRUE), score = sample(LETTERS[1:4], 100, replace = TRUE)) # modified Mode function # https://stackoverflow.com/questions/2547402/is-there-a-built-in-function-for-finding-the-mode Mode_and_freq &lt;- function(x) { ux &lt;- unique(x) the_mode &lt;- ux[which.max(tabulate(match(x, ux)))] list(the_mode, sum(x == the_mode)) } result_df &lt;- sapply(fk_df, function(x){Mode_and_freq(x)}) %&gt;% t() %&gt;% as.data.frame() %&gt;% mutate(V1 = as.character(V1)) %&gt;% rename(the_mode = V1, the_freq = V2) %&gt;% tibble::add_column(var_name = names(fk_df), .after = 0) result_df ## var_name the_mode the_freq ## 1 sex M 54 ## 2 age 24 17 ## 3 score C 26 Or, we use the following code: library(dplyr) library(purrr) set.seed(12022018) fk_df &lt;- # using data_frame rather than data.frame, for dealing with &quot;negative&quot; factor effect data_frame(sex = sample(c(&quot;M&quot;, &quot;F&quot;), 100, replace = TRUE), age = sample(19:25, 100, replace = TRUE), score = sample(LETTERS[1:4], 100, replace = TRUE)) # modified Mode function # https://stackoverflow.com/questions/2547402/is-there-a-built-in-function-for-finding-the-mode Mode_and_freq &lt;- function(x) { ux &lt;- unique(x) the_mode &lt;- ux[which.max(tabulate(match(x, ux)))] list(the_mode, sum(x == the_mode)) } re_list &lt;- map(fk_df, Mode_and_freq) result_df_2 &lt;- data.frame(v_name = names(re_list)) %&gt;% mutate(the_mode = map_chr(re_list, function(x) x[[1]]), the_freq = map_int(re_list, function(x) x[[2]])) result_df_2 ## v_name the_mode the_freq ## 1 sex M 54 ## 2 age 24 17 ## 3 score C 26 Example 3: This is another example to use sapply (or lapply()). We want to split the words and descriptions in a dictionary. library(dplyr) my_dict &lt;- data_frame(record = c(&quot;a : ace&quot;, &quot;b: boy&quot;, &quot;c: coy &quot;)) result_df &lt;- my_dict %&gt;% mutate(word_desc = strsplit(record, split = &quot;:&quot;, fixed = TRUE)) %&gt;% mutate(word = sapply(word_desc, function(x) unlist(x)[1])) %&gt;% mutate(description = sapply(word_desc, function(x) unlist(x)[2])) %&gt;% mutate(word = trimws(word, which = &quot;both&quot;), description = trimws(description, which = &quot;both&quot;)) result_df ## # A tibble: 3 x 4 ## record word_desc word description ## &lt;chr&gt; &lt;list&gt; &lt;chr&gt; &lt;chr&gt; ## 1 &quot;a : ace&quot; &lt;chr [2]&gt; a ace ## 2 &quot;b: boy&quot; &lt;chr [2]&gt; b boy ## 3 &quot;c: coy &quot; &lt;chr [2]&gt; c coy Example 4: This is an example for dealing with list column. library(dplyr) library(tidyr) # for nest() library(purrr) fk_df &lt;- data_frame(ID = as.character(1:5), v1 = 1:5, v2 = 2:6, v3 = 3:7) wk_df_1 &lt;- fk_df %&gt;% group_by(ID) %&gt;% nest(.key = &quot;the_list&quot;) wk_df_2 &lt;- wk_df_1 %&gt;% mutate(the_sum = map_dbl(the_list, sum)) %&gt;% # mutate(the_mean = map_dbl(the_list, mean)) # this does not work mutate(the_mean = map_dbl(the_list, function(x) mean(unlist(x)))) # this works! wk_df_2 ## # A tibble: 5 x 4 ## ID the_list the_sum the_mean ## &lt;chr&gt; &lt;list&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 &lt;tibble [1 x 3]&gt; 6 2 ## 2 2 &lt;tibble [1 x 3]&gt; 9 3 ## 3 3 &lt;tibble [1 x 3]&gt; 12 4 ## 4 4 &lt;tibble [1 x 3]&gt; 15 5 ## 5 5 &lt;tibble [1 x 3]&gt; 18 6 Example 5: Another example for dealing with list columns. Note the use of map2(). library(dplyr) library(purrr) set.seed(20190206) hp_func &lt;- function(a_list) {temp &lt;- unlist(a_list) re &lt;- round(quantile(temp, probs = c(0.025, 0.5, 0.975)), 1) return(re) } fk_df &lt;- data_frame(mu = c(1, 10, 100), st_dev = rep(1, 3)) %&gt;% mutate(mu = as.list(mu), st_dev = as.list(st_dev)) %&gt;% mutate(rv = map2(mu, st_dev, function(x, y) rnorm(100, mean = x, sd = y))) %&gt;% mutate(the_quantiles = map(rv, hp_func)) %&gt;% mutate(q_dot_025 = map_dbl(the_quantiles, function(x) x[[1]]), q_dot_5 = map_dbl(the_quantiles, function(x) x[[2]]), q_dot_975 = map_dbl(the_quantiles, function(x) x[[3]])) fk_df ## # A tibble: 3 x 7 ## mu st_dev rv the_quantiles q_dot_025 q_dot_5 q_dot_975 ## &lt;list&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 &lt;dbl [1]&gt; &lt;dbl [1]&gt; &lt;dbl [100]&gt; &lt;dbl [3]&gt; -1 0.8 2.7 ## 2 &lt;dbl [1]&gt; &lt;dbl [1]&gt; &lt;dbl [100]&gt; &lt;dbl [3]&gt; 8.4 10 11.5 ## 3 &lt;dbl [1]&gt; &lt;dbl [1]&gt; &lt;dbl [100]&gt; &lt;dbl [3]&gt; 98.1 100 102. 3.4 Regular expressions basic Metacharacters \\: for escaping ^: begin with power $: end with money +: one or more characters (greedy extension) *: zero or more characters (greedy extension) .: wildcard; often used as .+, which means “one or more characters”, and .*, which means “zero or more characters”. \\S: non-space character \\s: a white space [0-9]: single digit [a-z]: single lowercase letter [A-Z]: single uppercase letter (): extract particular sub string, e.g. (p|P), which means “p” or “P” NB: Inside a square bracket, a period is a period Examples: library(stringr) library(dplyr) # task 1 ------------------------------------------------------------------ ## based on: ## https://www.r-bloggers.com/regular-expressions-every-r-programmer-should-know/ files = c( &quot;tmp-project.csv&quot;, &quot;project.csv&quot;, &quot;project2-csv-specs.csv&quot;, &quot;project2.csv2.specs.xlsx&quot;, &quot;project_cars.ods&quot;, &quot;project-houses.csv&quot;, &quot;Project_Trees.csv&quot;,&quot;project-cars.R&quot;, &quot;project-houses.r&quot;, &quot;project-final.xls&quot;, &quot;Project-final2.xlsx&quot;) # We want to grab the files “project_cars.ods”, “project-houses.csv” and # “Project_Trees.csv”. (the_flag &lt;- str_detect(files, &quot;^(P|p)roject(_|-)[a-zA-Z]*\\\\.(ods|csv)$&quot;)) ## [1] FALSE FALSE FALSE FALSE TRUE TRUE TRUE FALSE FALSE FALSE FALSE (the_re &lt;- str_subset(files, &quot;^(P|p)roject(_|-)[a-zA-Z]*\\\\.(ods|csv)$&quot;)) ## [1] &quot;project_cars.ods&quot; &quot;project-houses.csv&quot; &quot;Project_Trees.csv&quot; # task 2 ------------------------------------------------------------------ ## remove prefix &quot;U_&quot; a_df &lt;- data.frame(x = c(letters[1:5], &quot;U_&quot;, &quot;9&quot;, NA)) %&gt;% mutate(y = paste0(&quot;U_&quot;, x)) %&gt;% mutate(z = gsub(&quot;^U_&quot;, &quot;&quot;, y)) # task 3 ------------------------------------------------------------------ ## remove suffix &quot;.xlsx&quot; b_df &lt;- data.frame(file_name = files) %&gt;% mutate(new_file_name = gsub(&quot;\\\\.xlsx&quot;, &quot;&quot;, file_name)) "],
["tricky-plotting.html", "4 Tricky plotting 4.1 Bar charts", " 4 Tricky plotting 4.1 Bar charts We are going to create a bar chart. Here the requirements are: Bars are horizontal Bars are stacked In order, that is, the labels are in some order and the bars stacked in some order For each bar, put a number in the middle Using the colors provided by us rather than the default one library(dplyr) library(ggplot2) # utility functions ------------------------------------------------------- ## a helper function to find moving averages, which will be the positions for ## the counts my_mv_avg &lt;- function(x) {n &lt;- length(x) y &lt;- rep(0, n) y[1] &lt;- x[1] / 2 for(i in 2:n) y[i] &lt;- (x[i-1] + x[i]) / 2 y } ## self-defined scale_fill scale_fill_larry &lt;- function(...){ ggplot2:::manual_scale(&#39;fill&#39;, values = setNames(c(&quot;#77ec20&quot;, &quot;#ffc3a0&quot;, &quot;#20c3ff&quot;, &quot;#EA8E6C&quot;, &quot;#cc99cc&quot;, &quot;#fff68f&quot;, &quot;#66cdaa&quot;), c(&quot;apple&quot;, &quot;orange&quot;, &quot;kiwi fruit&quot;, &quot;banana&quot;, &quot;pear&quot;, &quot;plum&quot;, &quot;peach&quot;)), ...)} # data -------------------------------------------------------------------- ## prepare data fake_raw_data &lt;- data.frame(market = sample(c(&quot;Market 1&quot;, &quot;Market 2&quot;, &quot;Market 3&quot;), 1000, replace = TRUE), fruit = sample(c(&quot;apple&quot;, &quot;orange&quot;, &quot;kiwi fruit&quot;, &quot;banana&quot;, &quot;pear&quot;, &quot;plum&quot;, &quot;peach&quot;), 1000, replace = TRUE)) plotting_df &lt;- fake_raw_data %&gt;% group_by(market, fruit) %&gt;% tally() %&gt;% mutate(fruit = factor(fruit, levels = c(&quot;apple&quot;, &quot;orange&quot;, &quot;kiwi fruit&quot;, &quot;banana&quot;, &quot;pear&quot;, &quot;plum&quot;, &quot;peach&quot;))) %&gt;% ungroup() %&gt;% group_by(market) %&gt;% arrange(market, fruit) %&gt;% mutate(count_cum = cumsum(n)) %&gt;% mutate(plot_posi = my_mv_avg(count_cum)) # plotting ---------------------------------------------------------------- p &lt;- plotting_df %&gt;% # the order should be top-down or right-left # thus need to set the levels manually mutate(fruit = factor(fruit, levels = c(&quot;peach&quot;, &quot;plum&quot;, &quot;pear&quot;, &quot;banana&quot;, &quot;kiwi fruit&quot;, &quot;orange&quot;, &quot;apple&quot;))) %&gt;% ggplot(aes(x = market, y = n, fill = fruit)) + geom_bar(stat = &quot;identity&quot;, position = &quot;stack&quot;, width = 0.4) + geom_text(aes(x = market, y = plot_posi, label = scales::comma(n))) + labs(x = &quot;&quot;, y = &quot;(NB: The unit is ton)&quot;, title = &quot;A tricky bar chart&quot;) + # use specified colors to fill scale_fill_larry() + # horizontal bars coord_flip() + # put the labels in a specific order scale_x_discrete(limits = c(&quot;Market 3&quot;, &quot;Market 2&quot;, &quot;Market 1&quot;)) + theme(# axis.title.x = element_blank(), axis.text.x = element_blank(), axis.ticks.x = element_blank()) print(p) "]
]
